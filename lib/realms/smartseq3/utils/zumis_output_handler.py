from pathlib import Path

from lib.utils.logging_utils import custom_logger

logging = custom_logger(__name__.split('.')[-1])

class zUMIsOutputHandler:
    # TODO: Only pass the project_name if project_info is not used anywhere else
    def __init__(self, sample):
        self.sample_id = sample.id
        self.project_name = sample.project_info.get('project_name', None) # TODO: Remove this if not used anywhere else / see todo above
        self.config = sample.config

        # Define sample folder structure
        self.base_dir = Path(self.config['smartseq3_dir']) / 'projects' / self.project_name
        self.sample_dir = self.base_dir / self.sample_id
        self.zumis_output_dir = self.sample_dir / 'zUMIs_output'
        self.stats_dir = self.sample_dir / 'zUMIs_output' / 'stats'
        self.expression_dir = self.sample_dir / 'zUMIs_output' / 'expression'
        self.fastq_files_dir = self.sample_dir / 'fastq_files'

        # Define critical file paths
        self.gene_counts_fpath = self.stats_dir / f"{self.sample_id}.genecounts.txt"
        self.reads_per_cell_fpath = self.stats_dir / f"{self.sample_id}.readspercell.txt"
        self.umicount_inex_loom_fpath = self.expression_dir / f"{self.sample_id}.umicount.inex.all.loom"
        self.bc_umi_stats_fpath = self.zumis_output_dir / f"{self.sample_id}kept_barcodes_binned.txt.BCUMIstats.txt"
        self.zumis_log_fpath = self.sample_dir / f"{self.sample_id}.zUMIs_runlog.txt"

        # NOTE: This is a future file that will be created by the report generator
        # TODO: whether PDF or HTML should be decided by the report generator
        self.report_fpath = self.zumis_output_dir / f"{self.sample_id}_report.pdf"


    # TODO: Add checks to ensure that the paths exist
    def get_stat_files(self):
        """Retrieve paths to critical statistics files generated by zUMIs."""
        stats_files = {
            'genecounts': self.gene_counts_fpath,
            'readspercell': self.reads_per_cell_fpath,
            'bc_umi_stats': self.bc_umi_stats_fpath
        }
        return stats_files

    # TODO: Add checks to ensure that the paths exist
    def get_counts_loom_file(self):
        """Retrieve paths to loom files containing UMI counts."""
        loom_file = {
            'umicount_inex': self.umicount_inex_loom_fpath
        }
        return loom_file

    def create_fastq_folder(self):
        """Create fastq_files folder and manage soft links."""
        self.fastq_files_path.mkdir(exist_ok=True)
        # Logic to create soft links to fastq files

    def get_gene_counts_file_path(self):
        """Get path to the gene counts file."""
        return self.zumis_output_path / 'stats' / f"{self.sample_id}.genecounts.txt"

    def get_reads_per_cell_file_path(self):
        """Get path to the reads per cell file."""
        return self.zumis_output_path / 'stats' / f"{self.sample_id}.readspercell.txt"

    def is_output_valid(self):
        """
        Checks if the sample root directory and all expected zUMIs output files are present.

        This method verifies the presence of the sample root directory and all critical files generated by the zUMIs pipeline.

        Returns:
            bool: True if the root directory and all expected files are found, False otherwise.
        """
        # Check if sample output dir exists
        self.sample_dir = Path(self.sample_dir)
        if not (self.sample_dir.exists() and self.sample_dir.is_dir()):
            # TODO: In this case it might not make sense to continue, probably skip and report the issue (through Slack?)
            logging.error(f"Sample {self.sample_id} directory does not exist after processing: {self.sample_dir}")
            return

        expected_files = [
            self.gene_counts_fpath,
            self.reads_per_cell_fpath,
            self.umicount_inex_loom_fpath,
            self.bc_umi_stats_fpath,
            self.zumis_log_fpath,
            # Add more paths to expected files here
        ]

        missing_files = [file.name for file in expected_files if not file.exists()] # or file.stat().st_size == 0]

        if missing_files:
            missing_files_str = "\n\t".join(missing_files)
            logging.warning(f"Missing or empty crucial zUMIs output files for sample {self.sample_id} in {self.sample_dir}:\n[\n\t{missing_files_str}\n]")
            return False
        else:
            logging.info(f"All expected zUMIs output files are present for sample {self.sample_id}.")
            return True
